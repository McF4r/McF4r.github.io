<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>OpenGL</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="34db96bc-12d7-4e54-8601-2a42d8399e56" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/OpenGLLogo.png"/></div><h1 class="page-title">OpenGL</h1></header><div class="page-body"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c224b75e-eaee-4218-a8ce-7e60bcbe09ca"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">The learning of OpenGL API</div></figure><nav id="4c174354-06a4-48a0-a52f-37f4433f42aa" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#80be299a-062a-4f8e-9bda-11a933ea0038">Xcode环境搭建</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#755644f1-6d78-4265-bcb1-cc844ba59cf6">编译顺序报错(移动一下位置)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1ce77390-8f3d-41ea-9cd8-016853d84cf7">如果是在使用glew的静态库,那么就需要在这里声明GLEW_STATIC,但是似乎在xcode中我使用的是dylib,应该就不用声明static了</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#7c5f9242-7c93-4e47-b17e-447cd35a7434">Date: <time>@July 10, 2022</time> </a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#488c2053-5197-49e3-a920-9fdb74eb699d">Topic: OpenGL学习</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b94343aa-9525-4da7-9678-ec3d87e7ef14">第一个OpenGL窗口!</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c0d3563f-3e96-4dad-a456-40b98ac4e7ce">OpenGL以state machine的状态工作</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fd386c91-a7e6-4fda-9b09-d607e1465fc0"><mark class="highlight-purple">Give OpenGL the data</mark></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e5afc027-91d0-4db1-82d3-e02509050189">两种methods来画一个三角形</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#96e551ef-1a6c-46bf-add3-9537fa63e5c4">Vertex属性指针</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#a579e6af-4a6d-4145-b562-6c8de2cb520e">启动vertex</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#687f035f-8529-4dae-9da2-d0d766e9f32c">什么是Vertex shader</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9ba2a3e0-8662-41b0-a20d-33f596af19d5">All you need to render a red triangle</a></div></nav><h1 id="80be299a-062a-4f8e-9bda-11a933ea0038" class="">Xcode环境搭建</h1><p id="f9c3be0d-13ad-4a5d-af42-8262ca0e660c" class="">[glew+glfw(vulkan也用到了这个)]</p><p id="1a34b082-24bc-4b30-8361-9b7342dd7d7d" class="">图二等于图四,相当关键 ⇒ 如果<mark class="highlight-red">使用非官方的链接库,需要下拉菜单选中Embed选项</mark></p><figure id="8f579373-fc04-46ea-9280-94b335d367db" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled.png"><img style="width:2124px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled.png"/></a></figure><figure id="62cc1f56-91e3-48e6-bbb0-814d10af57ee" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%201.png"><img style="width:1564px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%201.png"/></a></figure><figure id="a79fadf0-f616-4e62-b859-73ba51304ce0" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%202.png"><img style="width:2284px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%202.png"/></a></figure><figure id="2e1130d6-d9e3-4d57-ba95-3cebd1dace67" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%203.png"><img style="width:2312px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%203.png"/></a></figure><p id="702ebbdd-6056-4144-86c3-2b2963259e29" class="">
</p><h1 id="755644f1-6d78-4265-bcb1-cc844ba59cf6" class="">编译顺序报错(移动一下位置)</h1><p id="2ea95e02-cd73-42ea-b394-fb47cfad2a9b" class="">This usually can be resolved by moving the target&#x27;s Headers build phase before Compile Sources</p><figure id="3b6e660d-0ce1-4b04-8247-35b82168cb92" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%204.png"><img style="width:1506px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%204.png"/></a></figure><h2 id="1ce77390-8f3d-41ea-9cd8-016853d84cf7" class="">如果是在使用glew的静态库,那么就需要在这里声明GLEW_STATIC,但是似乎在xcode中我使用的是dylib,应该就不用声明static了</h2><figure id="228b40ef-fccf-4dc8-8660-6359c806da30" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%205.png"><img style="width:1718px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%205.png"/></a></figure><figure id="d08b759d-99fb-426c-8f04-acfa96968396" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%206.png"><img style="width:1892px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%206.png"/></a></figure><p id="9fa6b2b0-f64a-4809-af16-65201876922c" class="">
</p><h3 id="7c5f9242-7c93-4e47-b17e-447cd35a7434" class="">Date: <time>@July 10, 2022</time> </h3><h3 id="488c2053-5197-49e3-a920-9fdb74eb699d" class="">Topic: OpenGL学习</h3><div id="ea654041-d0fd-48ac-9331-e1584adcf12c" class="column-list"><div id="c8d2b2ba-3e77-43c2-ac0d-0fd1a671fd9c" style="width:25%" class="column"><h2 id="b94343aa-9525-4da7-9678-ec3d87e7ef14" class="">第一个OpenGL窗口!</h2><p id="26119034-1080-49f1-ad3b-7072ead3cc8b" class="">
</p><p id="08825a32-d971-45ae-b46a-4f29fb1a0372" class="">
</p><p id="4139609d-f994-42f3-af9c-f36a2e75bef1" class="">
</p><p id="021002ad-9402-4c28-a896-1035ebb9475d" class="">
</p><p id="fe853376-1162-4ebb-aed2-56962118d0a7" class="">
</p><p id="26a6e0c4-d193-48f3-9460-674078d92cbb" class="">
</p><p id="573e277e-5927-422e-ae38-7fd1c218c454" class="">
</p><p id="d2d0f65e-7c19-4a7f-ad3c-5c30ac97c9d3" class="">
</p><p id="b116f221-a22c-4ab8-b614-60474beb5aec" class="">
</p><p id="168d35f8-674e-47d7-a470-c96e210ad514" class="">
</p><p id="94030d97-cf94-402e-8794-0d3c474a3d74" class="">
</p><p id="0257951a-fb5f-4260-b43a-387b36af3795" class="">
</p><p id="30c1f67e-7a76-4f86-944b-259bf1036b69" class="">
</p><p id="cb938689-7b30-4ca1-8523-e0140f46fb9d" class="">
</p><p id="bed45349-8989-4895-b913-362b39c7552a" class="">
</p><p id="1a93d85e-5069-4df1-8f3c-f46aa6be7df7" class="">
</p><h2 id="c0d3563f-3e96-4dad-a456-40b98ac4e7ce" class="">OpenGL以state machine的状态工作</h2><p id="c64eff19-3711-45a5-ab5b-4dea141c34f2" class="">这里就是声明了一个buffer用于储存vertex信息</p><p id="49e1b56e-9746-47c1-bbcd-da9e73474da4" class="">
</p><p id="5fa11e4e-b662-4dc2-8b2d-250cd6c977c0" class="">
</p><h2 id="fd386c91-a7e6-4fda-9b09-d607e1465fc0" class=""><mark class="highlight-purple">Give OpenGL the data</mark></h2><p id="410b394d-9581-427a-824a-cf8d75aff145" class="">glGenBuffers()
glBindBuffer()
glBufferData()</p><p id="a659ac91-118e-4fb0-b6b0-985877ee74bb" class="">
</p><h3 id="e5afc027-91d0-4db1-82d3-e02509050189" class="">两种methods来画一个三角形</h3><p id="f11ac8a6-377e-411c-80f9-ce3801f08e2f" class="">glDrawArrays()
glDrawElements()</p><p id="7c904e01-cbd9-49da-8c4c-9340bb12c52a" class="">
</p><h3 id="96e551ef-1a6c-46bf-add3-9537fa63e5c4" class="">Vertex属性指针</h3><p id="ca5ed215-fa9c-452e-a184-8566d3278ac4" class="">
</p><p id="c1dc90bd-82bd-4033-8d08-08fefe16eb14" class="">
</p><h3 id="a579e6af-4a6d-4145-b562-6c8de2cb520e" class="">启动vertex</h3><p id="0e04f6b8-b5f7-4238-93ee-fc82b1b961be" class="">
</p><p id="75101009-aa9f-43aa-9bcb-d33574e749b1" class="">
</p><p id="ef3ba9c5-623c-480b-87ef-d41775e0eb5b" class="">
</p><p id="044af99e-4e98-4a5a-9a62-2950a95a767a" class="">虽然我们还没有写shader(着色器)相关的代码</p><p id="7a74d84d-1af7-4e67-bb75-197d850550fb" class="">但是这个时候已经能看到三角形被渲染了</p><p id="cffc813d-c868-4e38-a924-3795e561718e" class="">
</p><p id="ec7530a2-2e53-4db5-b6b9-f4923b5e9bd0" class="">原因是某些显卡驱动会自动提供一个默认的shader</p><p id="cc10e241-0679-47aa-b81f-561440872930" class="">
</p><p id="7df46607-9969-45f1-bbca-31ca29f18854" class="">
</p><h3 id="687f035f-8529-4dae-9da2-d0d766e9f32c" class="">什么是Vertex shader</h3><p id="c17e390f-e907-46d0-bbca-740dcaa98b40" class="">
</p><p id="d62f4e1f-253c-4534-ae17-0493564e4864" class="">
</p></div><div id="7092c05f-71bd-412e-858d-946171449ed5" style="width:75%" class="column"><figure id="d40c0d46-deec-4bea-a51b-b4fb6267bb3b" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%207.png"><img style="width:1280px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%207.png"/></a></figure><figure id="b8a70a5a-a705-43c3-9ea2-d844f0c0575a" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%208.png"><img style="width:1192px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%208.png"/></a></figure><figure id="0b332b9a-17eb-4cb8-ada5-64999ba2211e" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%209.png"><img style="width:1982px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%209.png"/></a></figure><p id="a85de1fc-e06c-4604-8d44-749241b65b3c" class="">
</p><p id="a33f5d42-0fee-47bf-9cca-7103b123033e" class="">
</p><figure id="bac9d43f-3f89-4094-ab49-a97a5917258f" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2010.png"><img style="width:980px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2010.png"/></a></figure><p id="dbbf157a-c20f-47d5-b201-a6e237d63a2a" class="">
</p><p id="d1e66a6d-2dda-4866-9a1a-cc83b7323367" class="">
</p><p id="215fd6b9-0fe5-4a3b-9b1f-c8dc7167ceea" class="">
</p><p id="06493eec-b937-41c6-a331-9b002cebd77f" class="">
</p><p id="c733db3b-6479-4cf8-a85e-6f9389f60886" class="">
</p><figure id="e54c4cb6-45e0-4542-a9cc-57882f66ccc6" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2011.png"><img style="width:2042px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2011.png"/></a></figure><figure id="5f9e8c7c-55ba-40ef-8284-aede83f1d420" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2012.png"><img style="width:1828px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2012.png"/></a></figure><figure id="67650584-cc4a-4832-82d7-247239fce0b9" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2013.png"><img style="width:1580px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2013.png"/></a></figure><figure id="0d1e4be2-7c34-4d70-baed-f4c9f0c74a56" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2014.png"><img style="width:758px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2014.png"/></a></figure><p id="d733a643-58d2-444a-a78a-05ef11292b8d" class="">
</p><figure id="d1d4d140-33d7-4bfd-80d3-326b3c2a3659" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2015.png"><img style="width:3576px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2015.png"/></a></figure><p id="377c1e2c-d30d-469f-aeff-88cf1bcb6a4a" class="">
</p><p id="5f35af0b-4607-4444-bfca-54b8bcbd138b" class="">
</p><p id="6a3dad01-a4ac-425c-856a-d8188ae5181e" class="">记录顶点的位置,也被用来解析数据从属性到下一阶段</p><p id="bc16595e-eb30-4007-a8bc-c3467a4c6f74" class="">
</p><figure id="de673f70-2d23-4a46-9c4e-9d980ae03f16" class="image"><a href="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2016.png"><img style="width:2318px" src="OpenGL%2034db96bc12d74e5486012a42d8399e56/Untitled%2016.png"/></a></figure></div></div><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="70e621a3-7438-4b0d-824e-4d4634647400"><div style="font-size:1.5em"><span class="icon">📌</span></div><div style="width:100%"><strong>SUMMARY:</strong></div></figure><p id="73ec5721-cdbc-4c80-b6d4-960200a9e2ef" class="">
</p><hr id="b1979f95-7730-4337-95ac-45b93259d153"/><h1 id="9ba2a3e0-8662-41b0-a20d-33f596af19d5" class="">All you need to render a red triangle</h1><pre id="2894d07e-ca07-4cac-b82d-b2e4e589a1ef" class="code code-wrap"><code>#define GL_SILENCE_DEPRECATION ; //用于取消deprecated警告
#include &lt;GL/glew.h&gt; //要放在最前面
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;


static unsigned int CompileShader(unsigned int type, const std::string&amp; source)
{
    //这是编译一个着色器需要写的所有代码
    
    //指明要生成的shader类型
    unsigned int id = glCreateShader(type);
    
    //返回一个以null结尾的不可变数组指针, 指向数组的第一个元素的地址, src就是一个raw string(原生的纯string)
    const char* src = source.c_str();// == &amp;source[0]
    
    /*
    glShaderSource — Replaces the source code in a shader object 替换shader对象的source code
        shader
            Specifies the handle of the shader object whose source code is to be replaced. 指明被替换源码的shader对象的handle
        count
            Specifies the number of elements in the string and length arrays. 指明数组中source code的数量
        string
            Specifies an array of pointers to strings containing the source code to be loaded into the shader. 指明指向source code字符串的指针数组
        length
            Specifies an array of string lengths. 指明一个字符串长度数组
     */
    glShaderSource(id, 1, &amp;src, nullptr);
    
    //Compiles the source code strings that have been stored in the shader object specified by shader.
    glCompileShader(id);
    
    //Error handling
    int result;
    
    /*
    glGetShaderiv - returns in params the value of a parameter for a specific shader object.
        GL_SHADER_TYPE
            GL_VERTEX_SHADER if shader is a vertex shader object,
            GL_GEOMETRY_SHADER if shader is a geometry shader object, and
            GL_FRAGMENT_SHADER if shader is a fragment shader object.
        GL_DELETE_STATUS
            GL_TRUE if shader is currently flagged for deletion, and
            GL_FALSE otherwise.
        GL_COMPILE_STATUS
            GL_TRUE if the last compile operation on shader was successful, and
            GL_FALSE otherwise.
        GL_INFO_LOG_LENGTH
            the size of the character buffer required to store the information log including the null termination character
            If shader has no information log, a value of 0 is returned.
        GL_SHADER_SOURCE_LENGTH
            the size of the character buffer required to store the shader source, including the null termination character.
            If no source code exists, 0 is returned.
     */
    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);
    if (result == GL_FALSE)
    {
        int length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);
        char* message = (char*)alloca(length * sizeof(char));
        
        /*
        shader
            Specifies the shader object whose information log is to be queried.
        maxLength
            Specifies the size of the character buffer for storing the returned information log.
        length
            Returns the length of the string returned in infoLog (excluding the null terminator).
        infoLog
            Specifies an array of characters that is used to return the information log.
        */
        glGetShaderInfoLog(id, length, &amp;length, message);
        
        std::cout &lt;&lt; &quot;Failed to compile&quot; &lt;&lt;
            (type == GL_VERTEX_SHADER ? &quot;vertex&quot; : &quot;fragment&quot;)
            &lt;&lt; &quot;shader!&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; message &lt;&lt; std::endl;
        glDeleteShader(0);
    }
    
    //返回id,赋值给vs
    return id;
}

    // 这个函数的参数是传入vertexshader和fragmentshader的source code
static unsigned int CreateShader(const std::string&amp; vertexShader, std::string&amp; fragmentShader)
{
    
    /*
    creates an empty program object and returns a non-zero value by which it can be referenced
    A program object is an object to which shader objects can be attached.
    This provides a mechanism to specify the shader objects that will be linked to create a program.
    It also provides a means for checking the compatibility of the shaders that will be used to create a program
    */
    unsigned int program = glCreateProgram();
    unsigned int vs =  CompileShader(GL_VERTEX_SHADER, vertexShader);
    unsigned int fs =  CompileShader(GL_FRAGMENT_SHADER, fragmentShader);
    
    /*
     Attaches a shader object to a program object
        program
            Specifies the program object to which a shader object will be attached.
        shader
            Specifies the shader object that is to be attached.
     */
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    
    //Links a program object
    glLinkProgram(program);
    
    /*Validates a program object
    checks to see whether the executables contained in program can execute given the current OpenGL state.
    The information generated by the validation process will be stored in program&#x27;s information log.*/
    glValidateProgram(program);
    
    //因为shader已经被link到program中了
    //所以可以delete了
    //不用detach是因为detach删除源码, 不利于后期debug
    glDeleteShader(vs);
    glDeleteShader(fs);
    
    return program;
}

int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;
    
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   #ifdef __APPLE__
     std::cout &lt;&lt; &quot;I&#x27;m apple machine&quot; &lt;&lt; std::endl;
     glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
   #endif

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window&#x27;s context current */
    glfwMakeContextCurrent(window);
    
    //这个函数需在一个opengl rendering context被渲染之后才能被call,也就是上面这个glfwMakeContextCurrent
    if(glewInit() != GLEW_OK)
        std::cout &lt;&lt; &quot;Error&quot; &lt;&lt; std::endl;
    
    //某一个新OpenGL函数
    //unsigned int a;
    //glGenBuffers(1, &amp;a);
    
    //vertex位置
    float positions[6] = {
        -0.5f, -0.5f,
         0.0f,  0.5f,
         0.5f, -0.5f
    };
    
//    /*give OpenGL the data
//    generate一个buffer,给我们一个ID;用于储存buffer的地址
//    选择使用的buffer
//    在buffer中存入position(六个浮点数大小的数组)*/
//    unsigned int buffer;
//
//    /*
//    Specifies the number of buffer object names to be generated.
//    Specifies an array in which the generated buffer object names are stored.
//    Buffer object names are unsigned integers.
//    The value zero is reserved, but there is no default buffer object for each buffer object target.
//     */
//    glGenBuffers(1, &amp;buffer);//generate几个buffer,返回一个ID;用于储存buffer的地址
//
//    glBindBuffer(GL_ARRAY_BUFFER, buffer);//选择使用的buffer
//    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);
//
//
//
//    //enable vertex启动vertex
//    glEnableVertexAttribArray(0);
//
//    /*
//     vertex属性指针,用于指定一个buffer的布局
//    因为positions只有一个属性,所以只需要调用一次这个函数
//    gen的第几个buffer,第一个所以是0
//    这个属性有两个components所以写2
//    positions中全是float所以用GL_FLOAT
//    是否选择初始化,这里因为position中已经都是float了,所以就不用初始化了
//    vertex中该属性的大小,两个float所以是 4byte * 2 = 8
//    到达下一个属性需要的byte,因为我们只有一个属性所以就是0,不然的话就是传入(const int*)
//     */
//    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
    
    unsigned int VBO, VAO;
    glGenBuffers(1, &amp;VBO);
    glGenVertexArrays(1, &amp;VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBindVertexArray(VAO);
    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float)*2, 0);
    
    std::string vertexShader =
        &quot;#version 330 core\n&quot;
        &quot;\n&quot;
        &quot;layout(location = 0) in vec4 position;\n&quot;
        &quot;\n&quot;
        &quot;void main()\n&quot;
        &quot;{\n&quot;
        &quot;   gl_Position = position;\n&quot;
        &quot;}\n&quot;;
    std::string fragmentShader =
        &quot;#version 330 core\n&quot;
        &quot;\n&quot;
        &quot;layout(location = 0) out vec4 color;\n&quot;
        &quot;\n&quot;
        &quot;void main()\n&quot;
        &quot;{\n&quot;
        &quot;   color = vec4(1.0, 0.0,0.0, 1.0);\n&quot;
        &quot;}\n&quot;;

    
    unsigned int shader = CreateShader(vertexShader, fragmentShader);
    glUseProgram(shader);
    
    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);
        
        //两种methods来画一个三角形
        glDrawArrays(GL_TRIANGLES, 0, 3);//从第几个点开始,画几个点
        //glDrawElements(GL_TRIANGLES, 3, unsigned int, NULL)//几个点,什么类型的输入,还没讲

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}</code></pre></div></article></body></html>